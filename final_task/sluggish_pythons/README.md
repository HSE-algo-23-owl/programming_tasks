# Алгоритм A*

## Описание алгоритма
Алгоритм A* - это алгоритм поиска пути, который использует эвристику для улучшения производительности. Он использует функцию оценки `f(n) = g(n) + h(n)`, где `g(n)` - это стоимость пути от начальной точки до `n`, а `h(n)` - это эвристическая оценка стоимости пути от `n` до конечной точки.

## Входные данные
- **Начальная точка**: Точка, с которой начинается поиск пути.
- **Конечная точка**: Точка, до которой нужно найти путь.
- **Граф**: Граф, представляющий пространство поиска.

## Выходные данные
- **Путь**: Последовательность точек от начальной до конечной, представляющая наиболее эффективный путь.

## Области допустимых значений
- **Начальная и конечная точки** должны быть в пределах графа.
- **Граф** может быть любым, включая непрерывные и дискретные пространства.

## Пошаговый пример выполнения алгоритма
1. Проверьте, являются ли начальная и конечная точки кортежами, представляющими координаты. Если нет, вызовите ошибку `ValueError`.
2. Проверьте, содержат ли кортежи начальной и конечной точек ровно два элемента. Если нет, вызовите ошибку `ValueError`.
3. Проверьте, находятся ли начальная и конечная точки в пределах графа. Если нет, вызовите ошибку `ValueError`.
4. Проверьте, являются ли начальная и конечная точки проходимыми (то есть, не являются ли они препятствиями). Если нет, вызовите ошибку `ValueError`.
5. Добавьте начальную точку в открытый список (кучу), где каждый элемент - это пара `(f, node)`, где `f` - это оценка стоимости пути для узла.
6. Инициализируйте `g_score` и `f_score` как словари, которые содержат стоимость пути от начальной точки до данного узла и оценку стоимости пути соответственно. Начальная точка имеет `g_score` равный 0 и `f_score` равный эвристической оценке стоимости пути от начальной до конечной точки.
7. Пока открытый список не пуст, делайте следующее:
   - А. Извлеките узел с наименьшим значением `f` из открытого списка.
   - Б. Если этот узел является конечной точкой, то мы нашли путь. Мы можем восстановить путь, следуя от конечной точки к начальной точке, используя словарь `came_from`.
   - В. В противном случае, для каждого соседа текущего узла, вычислите `tentative_g_score`, который равен `g_score` текущего узла плюс стоимость перехода от текущего узла к соседу.
   - Г. Если сосед еще не в `g_score` или `tentative_g_score` меньше `g_score` соседа, обновите `came_from`, `g_score` и `f_score` для соседа и добавьте соседа в открытый список.
8. Если вы исчерпали открытый список и не нашли путь, верните `None`, что указывает на то, что пути не существует.

