# Задание №18
## Оптимальное расписание. Уровневая стратегия.

1. В зависимости от варианта реализовать один из классов *GraphGenerator*, *GraphValidator*, *Schedule* в соответствующем файле:
   - graph_pack/graph_generator.py
   - graph_pack/graph_validator.py
   - schedule_pack/level_schedule.py
2. Для класса согласно варианту разработать набор LevelSchedule в соответствующем файле:
   - graph_pack/tests/test_graph_generator.py
   - test_graph_validator.py
   - schedule_pack/tests/test_level_schedule.py

## Примечания  
- Разработку вести в отдельной ветке, созданной на основе данной. В названии ветки префикс main заменить на название команды.  
- Изменения в ветке должны быть только в файлах реализуемого класса и соответствующих тестов, различные конфигурационные файлы и кэш IDE фиксировать не нужно.   
## Постановка задачи:
1. количество заданий произвольно;
2. все задания имеют одинаковую длительность;
3. задания зависимы, причём граф зависимостей имеет вид дерева, ориентированного к корню (или ориентированного леса);
4. запрещены прерывания при выполнении заданий;
5. количество работников произвольно;
6. работники универсальны;
7. производительность работников, размеры оплаты из труда и т.д. не учитываются;

*Требуется построить расписание выполнения всех заданий для заданного количества исполнителей в кратчайшие сроки.*

## Уровневая стратегия
Для построения расписания необходимо назначить приоритет для каждой задачи. В первую очередь приоритеты 1, 2, 3, ... назначаются стокам графа (вершины, из которых нет исходящих ребер). Если приоритеты 1, 2, 3, ..., t уже назначены, то приоритет (t + 1) назначается заданию, у которого прямой потомок имеет наименьший приоритет.

После того как приоритеты для всех задач назначены, задачи добавляются в расписание в соответствии с их приоритетом. В каждый момент времени выбираются задачи готовые к выполнению (для которых все предшествующие задачи выполнены к началу момента времени) из них для добавления в расписание выбирается задача с наибольшим приоритетом.
